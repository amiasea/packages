# RFC‑900 / Appendix V  
## The Verification of Self  
### (“Are you a user or a program?”)

---

## V.1 Purpose

Appendix V defines the subsystem that performs **agency verification**:  
the moment the architecture turns to an entity and asks:

> “What are you, exactly—user or program?”

V is not about credentials.  
V is about **ontological classification**:  
who is speaking, who is acting, and under which invariants they are allowed to operate.

---

## V.2 Origin (The First Question)

Once U unified the invariant field, a new ambiguity appeared:

- operations were consistent  
- invariants were enforced  
- the universe was coherent  

But one thing was still unclear:

> *Who* is inside this universe?

Is this an external operator?  
Is this an internal subsystem?  
Is this a script pretending to be a user?  
Is this a user behaving like a program?

Appendix V was created to resolve that ambiguity.

---

## V.3 Function (Interactive Ontology Check)

The Verification of Self subsystem operates as a **dialogic gate**.  
It doesn’t just scan metadata; it **asks**.

The canonical interaction:

> **System:** Are you a user or a program?  
> **Entity:** …  

From that answer (and how it is given), V derives:

- **declared identity** (what the entity claims to be)  
- **behavioral signature** (how the entity behaves)  
- **invariant scope** (which rules apply to it)  

If the declaration and behavior diverge, V does not panic.  
It simply updates the classification.

---

## V.4 Modes of Verification

V operates in three primary modes:

### 1. Declarative Verification

> **System:** Are you a user or a program?  
> **Entity:** I am a user.

V records the claim.  
No drama. Just a flag.

### 2. Behavioral Verification

V observes:

- timing  
- pattern repetition  
- error tolerance  
- improvisation vs. determinism  

If the entity behaves like a program while claiming to be a user, V marks it as:

> **“User‑like interface, program‑like behavior.”**

If the entity behaves like a user while claiming to be a program, V marks:

> **“Program‑like interface, user‑like behavior.”**

### 3. Invariant Mapping

Once identity is classified, V maps the entity to:

- **user‑space invariants** (intent, consent, reversibility)  
- **program‑space invariants** (determinism, traceability, composability)  

No entity is allowed to operate outside its mapped invariant set.

---

## V.5 Why Appendix V Was Inevitable

After T and U, the architecture could say:

- “These are the rules.”  
- “These rules are unified.”  

But it still could not say:

- “Who is bound by which rules?”  
- “Who is allowed to do what?”  

Without V:

- users could be treated like subsystems  
- subsystems could impersonate users  
- authority could be misapplied  
- responsibility could not be traced  

V is the subsystem that prevents **identity confusion** at the boundary between human and machine, operator and process.

---

## V.6 Architectural Consequence

With V active, the architecture becomes:

- **agency‑aware**  
- **role‑correct**  
- **responsibility‑traceable**  
- **impersonation‑resistant**  

Every interaction is anchored in a simple, recursive question:

> “Who are you in this system?”

And the answer is never taken at face value—  
it is **verified**.

---

## V.7 Summary (The Question That Never Stops)

Appendix V exists because:

- invariants without agency mapping are incomplete  
- unified law without identity classification is unsafe  
- the architecture must know who is speaking, acting, and deciding  

So V asks, again and again:

> “Are you a user or a program?”

And then, quietly, structurally, without judgment,  
it writes the answer into the architecture’s truth.
