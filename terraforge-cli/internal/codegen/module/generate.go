package module

import (
	"bytes"
	"fmt"
	"path/filepath"

	"github.com/amiasea/packages/terraforge-cli/internal/filesystem"
)

// Config controls where module files are written.
type Config struct {
	OutputDir string
}

// Generate writes Terraform module folders and files to disk.
func Generate(fs *filesystem.FS, mods []Module, cfg Config) error {
	if cfg.OutputDir == "" {
		return fmt.Errorf("output directory is required")
	}

	// Ensure the root output directory exists.
	if err := fs.WriteFile(filepath.Join(cfg.OutputDir, ".keep"), []byte{}); err != nil {
		return fmt.Errorf("failed to initialize output directory: %w", err)
	}

	// Generate one Terraform module per resource.
	for _, mod := range mods {
		modDir := filepath.Join(cfg.OutputDir, mod.Name)
		mainPath := filepath.Join(modDir, "main.tf")

		// Build the file content in memory.
		var buf bytes.Buffer

		fmt.Fprintf(&buf, "# Terraform module for %s\n", mod.Name)
		fmt.Fprintf(&buf, "# Generated by Terraforge\n\n")

		fmt.Fprintf(&buf, "resource \"%s\" \"%s\" {\n", mod.Type, mod.Name)

		// Write attributes
		for k, v := range mod.Attributes {
			fmt.Fprintf(&buf, "  %s = \"%s\"\n", k, v)
		}

		fmt.Fprintf(&buf, "}\n")

		// Write the file using the filesystem abstraction.
		if err := fs.WriteFile(mainPath, buf.Bytes()); err != nil {
			return fmt.Errorf("failed to write module file %s: %w", mainPath, err)
		}
	}

	return nil
}
